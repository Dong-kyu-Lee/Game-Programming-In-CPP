
### `A*` 알고리즘이 최적의 경로를 찾기 위한 조건
1. 시작점과 목표지점 사이에 경로가 (당연히)존재해야 한다.
2. 휴리스틱이 허용 가능해야 한다.
3. 모든 에지의 가중치가 0과 같거나 커야 한다.

### `A*`가 GBFS와 다른 점

- GBFS에서는 예상되는 비용을 휴리스틱`h(X)` 값만을 사용했다. 하지만, `A*`에서는 시작노드부터 임의의 노드까지의 실제 비용을 나타내는 **경로 비용(path-cost)**을 추가했다.
	- 경로 비용은 `g(x)`으로 표현한다.
	- `g(x)` = 시작노드 - 부모노드까지의 비용 + 부모노드 - 현재노드까지의 비용이다.
	- 그리고 다음 노드를 선택할 최종 비용 값은 다음과 같이 결정된다.
	- `f(x) = g(x) + h(x)`. 즉, `f(x)` 값이 가장 낮은 노드를 우선하여 탐색한다.
- GBFS에서 인접노드는 항상 현재 노드를 부모 노드로 삼았지만, `A*`에서는 경로비용`g(x)`을 따져 부모를 선택한다.
	- 경로 비용이 더 적은 부모 노드를 선택하므로써 가장 비용이 적게 드는 경로를 선택하게 된다.
- `A*`를 구현할 때에는 GBFS와 마찬가지로 노드의 데이터를 위한 구조체(`AStarScratch`)를 정의한다. GBFS에서 `g(x)`값을 저장하기 위해 `mActualFromStart` 변수를 추가하는 차이점이 있다.

```cpp
struct AStarScratch{
	const WegithedEdge* mParentEdge = nullptr;
	float mHeuristic = 0.0f; // h(x) 값
	float mActualFromStart = 0.0f; // g(x) 값
	bool mInOpenSet = false;
	bool mInClosedSet = false;
};
```

- 전체 코드
```cpp
using AStarMap = std::unordered_map<const WeightedGraphNode*, AStarScratch>;

bool GBFS(cibst WeightedGraph& g, const WeightedGraphNode* start, const WeightedGraphNode* goal, GBFSMap& outMap)
{
	std::vector<const WeightedGraphNode*> openSet;
	// 시작 노드를 현재 노드로 설정하고 닫힌 집합에 있다고 마킹한다.
	const WeightedGraphNode* current = start;
	outMap[current].mInClosedSet = true;
	do
	{
		for (const WeightedEdge* edge : current->mEdges)
		{
			const WeightedGraphNode* neighbor = edge->mTo;
			// 이 노드의 추가 데이터를 얻는다.
			AStarScratch& data = outMap[neighbor];
			// 닫힌 집합에 없는지를 확인
			if (!data.mInClosedSet)
			{
				if(!data.mInOpenSet)
				{
					// 열린 집합에 없다면 부모는 반드시 열린 집합에 있어야 한다.
					data.mParentEdge = edge;
					data.mHeuristic = ComputeHeuristic(neighbor, goal);
					// 실제 비용은 부모의 실제 비용 + 부모에서 자신으로 이동하는 Edge의 가중치다.
					data.mActualFromStart = outMap[current].mActualFromMap + edge->mWeight;
					data.mInOpenSet = true;
					openSet.emplace_back(neighbor);
				}
				else
				{
					// 현재 노드가 부모 노드가 될지를 판단하고자 새로운 실제 비용을 계산한다.
					float newG = outMap[current].mActualFromStart + edge->mWeight;
					if(newG < data.mActualFromStart)
					{
						// 현재 노드가 이 노드의 부모 노드로 채택됨
						data.mParentEdge = edge;
						data.mActualFromStart = newG;
					}
				}
			}
		}
	if (openSet.empty()) break;
	
	// 열린 집합에서 f(x)가 가장 낮은 비용을 가진 노드를 찾는다.
	auto iter = std::min_element(open.begin(), openSet.end(), [&outMap](const WeightedGraphNode* a, const WeightedGraphNode* b){
	return outMap[a].mHeuristic + outMap[a].mActualFromStart < outMap[b].mHeuristic + outMap[b].mActualFromStart; });
	// 현재 노드로 설정하고 열린 집합에서 닫힌 집합으로 이동시킨다.
	current = *iter;
	openSet.erase(iter);
	outMap[current].mInOpenSet = false;
	outMap[current].mInClosedSet = true;
	} while (current != goal);
	// 경로를 찾았는가?
	return (current == goal) ? true : false;
}
```